const path = require("path");
const vscode = require("vscode");
const cheerio = require("cheerio");
const axios = require("axios");

const debouceDelay = 3000;
const pipDependencyFiles = ["requirements.txt", "requirements-dev.txt"];
const jsDependencyFiles = ["package.json"];
const goDependencyFiles = ["go.mod"];
const nugetDependencyFiles = [".csproj"];

const decorationType = vscode.window.createTextEditorDecorationType({});
const storedDecorations = {};

function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

function activate() {
  if (vscode.window.activeTextEditor) {
    const { document } = vscode.window.activeTextEditor;
    if (document) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      if (pipDependencyFiles.includes(path.basename(document.fileName))) {
        decoratePythonLibs(document);
      } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
        decorateJsLibs(document);
      } else if (goDependencyFiles.includes(path.basename(document.fileName))) {
        decorateGoLibs(document);
      } else if (nugetDependencyFiles.includes(path.extname(document.fileName))) {
        decorateNugetLibs(document);
      }
    }
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decoratePythonLibs(document), debouceDelay);
    } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateJsLibs(document), debouceDelay);
    } else if (goDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateGoLibs(document), debouceDelay);
    } else if (nugetDependencyFiles.includes(path.extname(document.fileName))) {
      debounce(decorateNugetLibs(document), debouceDelay);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor?.document) {
      if (storedDecorations[editor.document.fileName]) {
        editor.setDecorations(decorationType, storedDecorations[editor.document.fileName]);
      } else {
        editor.setDecorations(decorationType, []);
        if (pipDependencyFiles.includes(path.basename(editor.document.fileName))) {
          debounce(decoratePythonLibs(editor.document), debouceDelay);
        } else if (jsDependencyFiles.includes(path.basename(editor.document.fileName))) {
          debounce(decorateJsLibs(editor.document), debouceDelay);
        } else if (goDependencyFiles.includes(path.basename(editor.document.fileName))) {
          debounce(decorateGoLibs(editor.document), debouceDelay);
        } else if (nugetDependencyFiles.includes(path.extname(editor.document.fileName))) {
          debounce(decorateNugetLibs(editor.document), debouceDelay);
        }
      }
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decoratePythonLibs(document), debouceDelay);
    } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateJsLibs(document), debouceDelay);
    } else if (goDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateGoLibs(document), debouceDelay);
    } else if (nugetDependencyFiles.includes(path.extname(document.fileName))) {
      debounce(decorateNugetLibs(document), debouceDelay);
    }
  });
}

function formatPythonLib(libraryString) {
  const [dep, version] = libraryString.split("==");
  return {
    dep,
    version,
  };
}

async function decoratePythonLibs(document) {
  const ecosystem = "pip";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const lines = document.getText().split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      if (line && line !== "" && !line.startsWith("#")) {
        const { dep, version } = formatPythonLib(line);

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

        const position = new vscode.Position(index, lines[index].length);
        const range = new vscode.Range(position, position);

        const decoration = {
          range,
          renderOptions: {
            after: {
              contentText: vulnDetails.total > 0
                ? ` ${formatVulnerabilityText(vulnDetails)} `
                : " No CVE found",
              color: getColorForSeverity(vulnDetails?.highestSeverity),
              fontWeight: "bold",
            },
          },
          hoverMessage: vulnDetails.total > 0
            ? new vscode.MarkdownString(vulnDetails.hoverMessage)
            : null,
        };

        decorations.push(decoration);

        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateJsLibs(document) {
  const ecosystem = "npm";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const json = JSON.parse(text);

    const dependencies = {
      ...json.dependencies,
      ...json.devDependencies,
    };

    const lines = text.split("\n");

    let decorations = [];

    for (const dep of Object.keys(dependencies)) {
      const version = dependencies[dep];

      const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

      const lineIndex = lines.findIndex((line) =>
        line.includes(`"${dep}":`)
      );

      if (lineIndex !== -1) {
        const position = new vscode.Position(
          lineIndex,
          lines[lineIndex].length
        );
        const range = new vscode.Range(position, position);

        const decoration = {
          range,
          renderOptions: {
            after: {
              contentText: vulnDetails.total > 0
                ? ` ${formatVulnerabilityText(vulnDetails)} `
                : " No CVE found",
              color: getColorForSeverity(vulnDetails?.highestSeverity),
              fontWeight: "bold",
            },
          },
          hoverMessage: vulnDetails.total > 0
            ? new vscode.MarkdownString(vulnDetails.hoverMessage)
            : null,
        };

        decorations.push(decoration);

        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateGoLibs(document) {
  const ecosystem = "go";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Match dependencies in go.mod file
      const match = line.match(/^(\S+)\s+v([\d.]+[-\w]*).*$/);
      if (match) {
        const dep = match[1]; // Dependency name
        const version = match[2]; // Dependency version

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateNugetLibs(document) {
  const ecosystem = "nuget";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Match dependencies in .csproj file
      const match = line.match(/<PackageReference Include="([^"]+)" Version="([^"]+)"\s*\/>/);
      if (match) {
        const dep = match[1]; // Dependency name
        const version = match[2]; // Dependency version

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep.toLowerCase(), version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries = 3) {
  if (!name) return { total: 0, highestSeverity: "none" };

  try {
    const vulnerabilities = await fetchVulnerabilities(name, version, ecosystem);

    const counts = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };
    let highestSeverity = getHighestSeverity(vulnerabilities, counts);

    const hoverMessage = vulnerabilities.map(cve => {
      let hoverLine = `* [${cve.cveId}](${cve.link}) - **${cve.severity}** - ${cve.description}`;
      if (cve.patchedVersions) {
        hoverLine += ` - **Fixed in ${cve.patchedVersions.join(', ')}**`;
      }
      return hoverLine;
    }).join('\n');

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
      hoverMessage,
    };
  } catch (error) {
    if (error.response && error.response.status === 429 && retries > 0) {
      // If we receive a 429 error, we delay and retry
      const retryAfter = error.response.headers['retry-after']
        ? parseInt(error.response.headers['retry-after'], 10) * 1000
        : 5000; // Default to 5 seconds if retry-after header is not present
      console.log(`Received 429, retrying after ${retryAfter / 1000} seconds...`);
      await delay(retryAfter);
      return fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries - 1);
    } else {
      console.error(`Error fetching vulnerabilities for ${name}:`, error);
      return { total: 0, highestSeverity: "none" };
    }
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchVulnerabilities(name, version, ecosystem) {
  // Fetch vulnerabilities related to the library and ecosystem
  const response = await axios.get(
    `https://github.com/advisories?query=affects:${name}+ecosystem:${ecosystem}`
  );
  const $ = cheerio.load(response.data);

  const domVulnerabilities = $(".Box-row");
  const vulnerabilities = [];

  const detailPromises = [];

  for (const domVuln of domVulnerabilities) {
    const description = $(domVuln).find("a.Link--primary").text().trim();
    let severity = $(domVuln).find("span.Label").first().text().trim();
    severity = severity === "Moderate" ? "Medium" : severity;
    const cveId = $(domVuln).find("span.text-bold").text().trim();
    const link = $(domVuln).find("a.Link--primary").attr("href").trim();
    const fullLink = `https://github.com${link}`;

    // Add a promise to fetch detailed vulnerability information
    detailPromises.push(
      axios.get(fullLink).then((detailResponse) => {
        const $detailPage = cheerio.load(detailResponse.data);

        const affectedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Affected versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        const patchedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Patched versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        // Compare the affected versions with the provided version
        if (isVersionAffected(version, affectedVersions, patchedVersions)) {
          vulnerabilities.push({
            description,
            severity,
            cveId,
            link: fullLink,
            affectedVersions,
            patchedVersions
          });
        }
      })
    );
  }

  await Promise.all(detailPromises);
  return vulnerabilities;
}

function isVersionAffected(version, affectedVersions, patchedVersions) {
  const normalizeVersion = (ver) =>
    ver
      .replace(/^[^0-9]+/, "")
      .split(".")
      .map(Number);

  const versionNumber = version && typeof version === 'string'
    ? normalizeVersion(version)
    : [Infinity, Infinity, Infinity];

  const isInRange = (range, versionNumber) => {
    return range.split(",").every((bound) => {
      const match = bound.trim().match(/(>=|<=|>|<|~|\^)?\s*([\d.]+)/);
      if (!match) return false;

      const operator = match[1] || "===";
      const boundVersion = normalizeVersion(match[2]);

      switch (operator) {
        case ">=":
          return compareVersions(versionNumber, boundVersion) >= 0;
        case "<=":
          return compareVersions(versionNumber, boundVersion) <= 0;
        case ">":
          return compareVersions(versionNumber, boundVersion) > 0;
        case "<":
          return compareVersions(versionNumber, boundVersion) < 0;
        case "~":
        case "^":
          return (
            compareVersions(versionNumber, boundVersion) >= 0 &&
            compareVersions(
              versionNumber,
              bumpVersion(boundVersion, operator)
            ) < 0
          );
        case "===":
          return compareVersions(versionNumber, boundVersion) === 0;
        default:
          return false;
      }
    });
  };

  const isPatched = patchedVersions.some(
    (patchedVersion) =>
      compareVersions(versionNumber, normalizeVersion(patchedVersion)) === 0
  );

  const isAffected = affectedVersions.some((affectedRange) =>
    isInRange(affectedRange, versionNumber)
  );

  return isAffected && !isPatched;
}

function compareVersions(versionA, versionB) {
  for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
    const a = versionA[i] || 0;
    const b = versionB[i] || 0;
    if (a > b) return 1;
    if (a < b) return -1;
  }
  return 0;
}

function bumpVersion(version, operator) {
  if (operator === "^") {
    if (version[0] > 0) {
      return [version[0] + 1, 0, 0];
    }
    return [0, version[1] + 1, 0];
  }
  if (operator === "~") {
    return [version[0], version[1] + 1, 0];
  }
  return version;
}

function getHighestSeverity(vulnerabilities, counts) {
  let highestSeverity = "none";
  vulnerabilities.forEach((vuln) => {
    switch (vuln.severity.toLowerCase()) {
      case "low":
        counts.low++;
        if (highestSeverity === "low") highestSeverity = "low";
        break;
      case "medium":
        counts.medium++;
        if (["low", "none"].includes(highestSeverity))
          highestSeverity = "medium";
        break;
      case "high":
        counts.high++;
        if (["low", "medium", "none"].includes(highestSeverity))
          highestSeverity = "high";
        break;
      case "critical":
        counts.critical++;
        highestSeverity = "critical";
        break;
    }
  });
  return highestSeverity;
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0)
    parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0)
    parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0)
    parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(", ");
}

function getColorForSeverity(severity) {
  switch (severity) {
    case "low":
      return "yellow";
    case "medium":
      return "orange";
    case "high":
      return "red";
    case "critical":
      return "red";
    default:
      return "green";
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
