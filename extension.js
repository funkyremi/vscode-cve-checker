const path = require("path");
const vscode = require("vscode");
const cheerio = require("cheerio");
const axios = require("axios");

const debouceDelay = 3000;
const pipDependencyFiles = ["requirements.txt", "requirements-dev.txt"];
const jsDependencyFiles = ["package.json"];

const decorationType = vscode.window.createTextEditorDecorationType({});

// Home made Debounce
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

function activate() {
  if (vscode.window.activeTextEditor) {
    const { document } = vscode.window.activeTextEditor;
    if (document) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      if (pipDependencyFiles.includes(path.basename(document.fileName))) {
        decoratePythonLibs(document);
      } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
        decorateJSLibs(document);
      }
    }
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decoratePythonLibs(document), debouceDelay);
    } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateJSLibs(document), debouceDelay);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor) {
      editor.setDecorations(decorationType, []);
      if (
        pipDependencyFiles.includes(
          path.basename(editor.document.fileName)
        )
      ) {
        debounce(decoratePythonLibs(editor.document), debouceDelay);
      } else if (
        jsDependencyFiles.includes(
          path.basename(editor.document.fileName)
        )
      ) {
        debounce(decorateJSLibs(editor.document), debouceDelay);
      }
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decoratePythonLibs(document), debouceDelay);
    } else if (jsDependencyFiles.includes(path.basename(document.fileName))) {
      debounce(decorateJSLibs(document), debouceDelay);
    }
  });
}

function formatPythonLib(libraryString) {
  const [name, version] = libraryString.split("==");
  return {
    name,
    version,
  };
}

async function decoratePythonLibs(document) {
  const ecosystem = "pip";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const lines = document.getText().split("\n");

    const vulnerabilities = await Promise.all(
      lines.map((line) => {
        const { name, version } = formatPythonLib(line.trim());
        return fetchVulnerabilitySeverityCounts(name, version, ecosystem);
      })
    );

    const decorations = vulnerabilities
      .map((vulnDetails, index) => {
        if (vulnDetails.total > 0) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          return {
            range,
            renderOptions: {
              after: {
                contentText: ` ${formatVulnerabilityText(vulnDetails)} `,
                color: getColorForSeverity(vulnDetails.highestSeverity),
                fontWeight: "bold",
              },
            },
          };
        }
        return null;
      })
      .filter((decoration) => decoration !== null);
    editor.setDecorations(decorationType, decorations);
  }
}

async function decorateJSLibs(document) {
  const ecosystem = "npm";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const json = JSON.parse(text);

    const dependencies = {
      ...json.dependencies,
      ...json.devDependencies,
    };

    const lines = text.split("\n");

    const vulnerabilities = await Promise.all(
      Object.keys(dependencies).map((dep) =>
        fetchVulnerabilitySeverityCounts(dep, dependencies[dep], ecosystem)
      )
    );

    const decorations = vulnerabilities
      .map((vulnDetails, index) => {
        if (vulnDetails.total > 0) {
          // Find the line where the dependency is declared
          const depName = Object.keys(dependencies)[index];
          const lineIndex = lines.findIndex((line) =>
            line.includes(`"${depName}":`)
          );

          if (lineIndex !== -1) {
            const position = new vscode.Position(
              lineIndex,
              lines[lineIndex].length
            );
            const range = new vscode.Range(position, position);

            return {
              range,
              renderOptions: {
                after: {
                  contentText: ` ${formatVulnerabilityText(vulnDetails)} `,
                  color: getColorForSeverity(vulnDetails.highestSeverity),
                  fontWeight: "bold",
                },
              },
            };
          }
        }
        return null;
      })
      .filter((decoration) => decoration !== null);

    editor.setDecorations(decorationType, decorations);
  }
}

async function fetchVulnerabilitySeverityCounts(name, version, ecosystem) {
  if (!name) return { total: 0, highestSeverity: "none" };

  try {
    const vulnerabilities = await fetchVulnerabilities(
      name,
      version,
      ecosystem
    );

    const counts = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };
    let highestSeverity = getHighestSeverity(vulnerabilities, counts);

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
    };
  } catch (error) {
    console.error(`Error fetching vulnerabilities for ${libraryName}:`, error);
    return { total: 0, highestSeverity: "none" };
  }
}

async function fetchVulnerabilities(name, version, ecosystem) {
  // Fetch vulnerabilities related to the library and ecosystem
  const response = await axios.get(
    `https://github.com/advisories?query=affects:${name}+ecosystem:${ecosystem}`
  );
  const $ = cheerio.load(response.data);

  const domVulnerabilities = $(".Box-row");
  const vulnerabilities = [];

  // Collect all promises to fetch detailed vulnerability information
  const detailPromises = [];

  for (let i = 0; i < domVulnerabilities.length; i++) {
    const element = domVulnerabilities[i];
    const description = $(element).find("a.Link--primary").text().trim();
    const severity = $(element).find("span.Label").first().text().trim();
    const cveId = $(element).find("span.text-bold").text().trim();
    const link = $(element).find("a.Link--primary").attr("href").trim();
    const fullLink = `https://github.com${link}`;

    // Add a promise to fetch detailed vulnerability information
    detailPromises.push(
      axios.get(fullLink).then((detailResponse) => {
        const $detailPage = cheerio.load(detailResponse.data);

        const affectedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Affected versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        const patchedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Patched versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        // Compare the affected versions with the provided version
        if (isVersionAffected(version, affectedVersions, patchedVersions)) {
          vulnerabilities.push({
            description,
            severity,
            cveId,
            link: fullLink,
          });
        }
      })
    );
  }

  // Wait for all detail fetches to complete
  await Promise.all(detailPromises);

  return vulnerabilities;
}

function isVersionAffected(version, affectedVersions, patchedVersions) {
  const normalizeVersion = (ver) =>
    ver
      .replace(/^[^0-9]+/, "")
      .split(".")
      .map(Number);
  const versionNumber = normalizeVersion(version);

  const isInRange = (range, versionNumber) => {
    return range.split(",").every((bound) => {
      const match = bound.trim().match(/(>=|<=|>|<|~|\^)?\s*([\d.]+)/);
      if (!match) return false;

      const operator = match[1] || "===";
      const boundVersion = normalizeVersion(match[2]);

      switch (operator) {
        case ">=":
          return compareVersions(versionNumber, boundVersion) >= 0;
        case "<=":
          return compareVersions(versionNumber, boundVersion) <= 0;
        case ">":
          return compareVersions(versionNumber, boundVersion) > 0;
        case "<":
          return compareVersions(versionNumber, boundVersion) < 0;
        case "~":
        case "^":
          return (
            compareVersions(versionNumber, boundVersion) >= 0 &&
            compareVersions(
              versionNumber,
              bumpVersion(boundVersion, operator)
            ) < 0
          );
        case "===":
          return compareVersions(versionNumber, boundVersion) === 0;
        default:
          return false;
      }
    });
  };

  const isPatched = patchedVersions.some(
    (patchedVersion) =>
      compareVersions(versionNumber, normalizeVersion(patchedVersion)) === 0
  );

  const isAffected = affectedVersions.some((affectedRange) =>
    isInRange(affectedRange, versionNumber)
  );

  return isAffected && !isPatched;
}

function compareVersions(versionA, versionB) {
  for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
    const a = versionA[i] || 0;
    const b = versionB[i] || 0;
    if (a > b) return 1;
    if (a < b) return -1;
  }
  return 0;
}

function bumpVersion(version, operator) {
  if (operator === "^") {
    if (version[0] > 0) {
      return [version[0] + 1, 0, 0];
    }
    return [0, version[1] + 1, 0];
  }
  if (operator === "~") {
    return [version[0], version[1] + 1, 0];
  }
  return version;
}

function getHighestSeverity(vulnerabilities, counts) {
  let highestSeverity = "low";
  vulnerabilities.forEach((vuln) => {
    switch (vuln.severity.toLowerCase()) {
      case "low":
        counts.low++;
        if (highestSeverity === "low") highestSeverity = "low";
        break;
      case "moderate":
        counts.medium++;
        if (["low", "none"].includes(highestSeverity))
          highestSeverity = "medium";
        break;
      case "high":
        counts.high++;
        if (["low", "medium", "none"].includes(highestSeverity))
          highestSeverity = "high";
        break;
      case "critical":
        counts.critical++;
        highestSeverity = "critical";
        break;
    }
  });
  return highestSeverity;
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0)
    parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0)
    parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0)
    parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(", ");
}

function getColorForSeverity(severity) {
  switch (severity) {
    case "low":
      return "#FFCA3A"; // Yellow
    case "medium":
      return "#FD8824"; // Orange
    case "high":
      return "#D31212"; // Red
    case "critical":
      return "#D31212"; // Red
    default:
      return "#000000"; // Black
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
