const path = require('path');
const vscode = require('vscode');
const axios = require('axios');

const dependencyFiles = ['requirements.txt', 'requirements-dev.txt'];

const decorationType = vscode.window.createTextEditorDecorationType({});

// Home made Debounce
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

function activate() {
  if (vscode.window.activeTextEditor) {
    const { document } = vscode.window.activeTextEditor;
    if (
      document
      && dependencyFiles.includes(path.basename(document.fileName))
    ) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      fetchVulnerabilities(document);
    }
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    if (dependencyFiles.includes(path.basename(document.fileName))) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      debouncedFetchVulnerabilities(document);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (
      editor
      && editor.dependencyFiles.includes(path.basename(editor.document.fileName))
    ) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      debouncedFetchVulnerabilities(editor.document);
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    if (dependencyFiles.includes(path.basename(document.fileName))) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      debouncedFetchVulnerabilities(document);
    }
  });
}

const debouncedFetchVulnerabilities = debounce(fetchVulnerabilities, 3000);

async function fetchVulnerabilities(document) {
  const editor = vscode.window.activeTextEditor;
  if (editor && editor.document === document) {
    const lines = document.getText().split('\n');

    const vulnerabilities = await Promise.all(
      lines.map((line) => getVulnerabilitiesCriticity(line.trim())),
    );

    const decorations = vulnerabilities
      .map((vulnDetails, index) => {
        if (vulnDetails.total > 0) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          return {
            range,
            renderOptions: {
              after: {
                contentText: ` ${formatVulnerabilityText(vulnDetails)} `,
                color: getColorForSeverity(vulnDetails.highestSeverity),
                fontWeight: 'bold',
              },
            },
          };
        }
        return null;
      })
      .filter((decoration) => decoration !== null);
    editor.setDecorations(decorationType, decorations);
  }
}

function getCpeString(libraryString) {
  // Parse the library string to extract name and version
  const [library, version] = libraryString.split('==');

  // Construct the CPE string
  const cpeName = `cpe:2.3:a:${library}:${library}:${version}`;

  return cpeName;
}

async function getVulnerabilitiesCriticity(libraryName) {
  if (!libraryName) return { total: 0, highestSeverity: 'none' };

  try {
    // Get the CPE string
    const cpeName = getCpeString(libraryName);

    // Construct the API URL
    const apiUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${cpeName}`;
    const apiKey = vscode.workspace.getConfiguration('nist').get('apiKey');

    const response = await axios.get(apiUrl, {
      headers: {
        apiKey,
      },
    });
    const { vulnerabilities } = response.data;

    const counts = {
      low: 0, medium: 0, high: 0, critical: 0,
    };
    let highestSeverity = 'low';

    vulnerabilities.forEach((vuln) => {
      const severity = getSeverity(vuln.cve.metrics);
      switch (severity.toUpperCase()) {
        case 'LOW':
          counts.low++;
          if (highestSeverity === 'low') highestSeverity = 'low';
          break;
        case 'MEDIUM':
          counts.medium++;
          if (['low', 'none'].includes(highestSeverity)) highestSeverity = 'medium';
          break;
        case 'HIGH':
          counts.high++;
          if (['low', 'medium', 'none'].includes(highestSeverity)) highestSeverity = 'high';
          break;
        case 'CRITICAL':
          counts.critical++;
          highestSeverity = 'critical';
          break;
      }
    });

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
    };
  } catch (error) {
    console.error(`Error fetching vulnerabilities for ${libraryName}:`, error);
    return { total: 0, highestSeverity: 'none' };
  }
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0) parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0) parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0) parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(', ');
}

function getSeverity(metrics) {
  if (metrics.cvssMetricV31 && metrics.cvssMetricV31.length > 0) {
    return metrics.cvssMetricV31[0].cvssData.baseSeverity;
  } if (metrics.cvssMetricV30 && metrics.cvssMetricV30.length > 0) {
    return metrics.cvssMetricV30[0].cvssData.baseSeverity;
  } if (metrics.cvssMetricV2 && metrics.cvssMetricV2.length > 0) {
    return metrics.cvssMetricV2[0].baseSeverity;
  }
  return 'LOW'; // Default to 'LOW' if no metrics are found
}

function getColorForSeverity(severity) {
  switch (severity) {
    case 'low':
      return '#FFCA3A'; // Yellow
    case 'medium':
      return '#FD8824'; // Orange
    case 'high':
      return '#D31212'; // Red
    case 'critical':
      return '#D31212'; // Red
    default:
      return '#000000'; // Black
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
