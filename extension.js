const path = require("path");
const vscode = require("vscode");
const cheerio = require("cheerio");
const axios = require("axios");

const decorationType = vscode.window.createTextEditorDecorationType({});
const storedDecorations = {};

function debounce(func, wait=3000) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

const fileDecorators = [
  { ecosystem: 'pip', regex: /(.+)?requirements(.+)?.txt$/i, decorator: decoratePythonLibs },
  { ecosystem: 'npm', regex: /^package\.json$/i, decorator: decorateNpmLibs },
  { ecosystem: 'go', regex: /^go\.mod$/i, decorator: decorateGoLibs },
  { ecosystem: 'nuget', regex: /\.csproj$/i, decorator: decorateNugetLibs },
  { ecosystem: 'composer', regex: /^composer\.json$/i, decorator: decorateComposerLibs },
  { ecosystem: 'maven', regex: /^pom\.xml$/i, decorator: decorateMavenLibs },
  { ecosystem: 'rust', regex: /^Cargo\.toml$/i, decorator: decorateRustLibs },
  { ecosystem: 'rubygems', regex: /^Gemfile$/i, decorator: decorateRubyLibs },
];

// Helper function to determine the correct decorator function based on the filename
function getDecoratorForFile(fileName) {
  for (const { regex, decorator } of fileDecorators) {
    if (regex.test(fileName)) {
      return decorator;
    }
  }
  return null;
}

// Helper function to apply decorations
function applyDecorations(document) {
  const fileName = path.basename(document.fileName);
  const decorator = getDecoratorForFile(fileName);
  if (decorator) {
    decorator(document);
  }
}

// Activate function with improvements
function activate() {
  const editor = vscode.window.activeTextEditor;
  if (editor?.document) {
    const document = editor.document;
    editor.setDecorations(decorationType, []);
    applyDecorations(document);
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    const editor = vscode.window.activeTextEditor;
    if (editor) {
      editor.setDecorations(decorationType, []);
      applyDecorations(document);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor?.document) {
      const document = editor.document;
      if (storedDecorations[document.fileName]) {
        editor.setDecorations(decorationType, storedDecorations[document.fileName]);
      } else {
        editor.setDecorations(decorationType, []);
        applyDecorations(document);
      }
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    const editor = vscode.window.activeTextEditor;
    if (editor?.document === document) {
      editor.setDecorations(decorationType, []);
      debounce(() => applyDecorations(document))();
    }
  });
}

function getDecoration(range, vulnDetails) {
  return {
    range,
    renderOptions: {
      after: {
        contentText: vulnDetails.total > 0
          ? ` ${formatVulnerabilityText(vulnDetails)} `
          : " No CVE found",
        color: getColorForSeverity(vulnDetails?.highestSeverity),
        fontWeight: "bold",
      },
    },
    hoverMessage: vulnDetails.total > 0
      ? new vscode.MarkdownString(vulnDetails.hoverMessage)
      : null,
  }
}

async function decoratePythonLibs(document) {
  const ecosystem = "pip";
  const editor = vscode.window.activeTextEditor;
  if (editor?.document === document) {
    const lines = document.getText().split("\n");
    let decorations = [];
    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      if (line && line !== "" && !line.startsWith("#")) {
        const [ dep, version ] = line.split("==");
        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);
        const position = new vscode.Position(index, lines[index].length);
        const range = new vscode.Range(position, position);
        const decoration = getDecoration(range, vulnDetails);
        decorations.push(decoration);
        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateNpmLibs(document) {
  const ecosystem = "npm";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const text = document.getText();
    let json;
    try {
      json = JSON.parse(text);
    } catch(e) {
      console.error('JSON file not valid', e);
    }

    const dependencies = {
      ...json.dependencies,
      ...json.devDependencies,
    };
    const lines = text.split("\n");

    let decorations = [];
    for (const dep of Object.keys(dependencies)) {
      const version = dependencies[dep];
      const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);
      const lineIndex = lines.findIndex((line) =>
        line.includes(`"${dep}":`)
      );
      if (lineIndex !== -1) {
        const position = new vscode.Position(
          lineIndex,
          lines[lineIndex].length
        );
        const range = new vscode.Range(position, position);
        const decoration = getDecoration(range, vulnDetails);
        decorations.push(decoration);
        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateGoLibs(document) {
  const ecosystem = "go";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      const match = line.match(/^(\S+)\s+v([\d.]+[-\w]*).*$/);
      if (match) {
        const dep = match[1];
        const version = match[2];
        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);
          const decoration = getDecoration(range, vulnDetails);
          decorations.push(decoration);
          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateNugetLibs(document) {
  const ecosystem = "nuget";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      const match = line.match(/<PackageReference Include="([^"]+)" Version="([^"]+)"\s*\/>/);
      if (match) {
        const dep = match[1];
        const version = match[2];
        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep.toLowerCase(), version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);
          const decoration = getDecoration(range, vulnDetails);
          decorations.push(decoration);
          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateComposerLibs(document) {
  const ecosystem = "composer";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const text = document.getText();
    let json;
    try {
      json = JSON.parse(text);
    } catch(e) {
      console.error('JSON file not valid', e);
    }

    const dependencies = {
      ...json.require,
      ...json['require-dev'],
    };

    const lines = text.split("\n");
    let decorations = [];

    for (const dep of Object.keys(dependencies)) {
      const version = dependencies[dep];
      const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);
      const lineIndex = lines.findIndex((line) =>
        line.includes(`"${dep}":`)
      );
      if (lineIndex !== -1) {
        const position = new vscode.Position(
          lineIndex,
          lines[lineIndex].length
        );
        const range = new vscode.Range(position, position);
        const decoration = getDecoration(range, vulnDetails);
        decorations.push(decoration);
        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateMavenLibs(document) {
  const ecosystem = "maven";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const text = document.getText();
    const lines = text.split("\n");
    let decorations = [];
    const dependencyRegex = /<dependency>\s*<groupId>([^<]+)<\/groupId>\s*<artifactId>([^<]+)<\/artifactId>\s*<version>([^<]+)<\/version>/;

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      if (line.includes('<dependency>')) {
        let depBlock = line;
        let depStartIndex = index;
        while (!depBlock.includes('</dependency>') && index < lines.length) {
          index++;
          depBlock += lines[index].trim();
        }
        const match = depBlock.match(dependencyRegex);
        if (match) {
          const groupId = match[1];
          const artifactId = match[2];
          const version = match[3];
          const vulnDetails = await fetchVulnerabilitySeverityCounts(`${groupId}:${artifactId}`, version, ecosystem);
          const position = new vscode.Position(depStartIndex, lines[depStartIndex].indexOf('<dependency>') + '<dependency>'.length); // Position after the <dependency> tag
          const range = new vscode.Range(position, position);
          const decoration = getDecoration(range, vulnDetails);
          decorations.push(decoration);
          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateRustLibs(document) {
  const ecosystem = "rust";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const lines = document.getText().split("\n");
    let decorations = [];
    let isInDependenciesSection = false;
    const dependencyRegex = /^([\w\-_]+)\s*=\s*"([\d\.\*]+)"/;

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      if (line.startsWith("[dependencies]") || line.startsWith("[dev-dependencies]")) {
        isInDependenciesSection = true;
      } else if (line.startsWith("[") && isInDependenciesSection) {
        isInDependenciesSection = false;
      }

      if (isInDependenciesSection) {
        const match = line.match(dependencyRegex);
        if (match) {
          const dep = match[1];
          const version = match[2];
          const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);
          const decoration = getDecoration(range, vulnDetails);
          decorations.push(decoration);
          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateRubyLibs(document) {
  const ecosystem = "rubygems";
  const editor = vscode.window.activeTextEditor;

  if (editor?.document === document) {
    const lines = document.getText().split("\n");
    let decorations = [];
    const gemRegex = /^gem ['"]([\w\-]+)['"],\s*['"]([\d.]+)['"]/;

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      const match = line.match(gemRegex);
      if (match) {
        const dep = match[1];
        const version = match[2];
        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);
        const position = new vscode.Position(index, lines[index].length);
        const range = new vscode.Range(position, position);
        const decoration = getDecoration(range, vulnDetails);
        decorations.push(decoration);
        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries = 3) {
  if (!name) return { total: 0, highestSeverity: "none" };

  try {
    const vulnerabilities = await fetchVulnerabilities(name, version, ecosystem);

    const counts = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };
    let highestSeverity = getHighestSeverity(vulnerabilities, counts);

    const hoverMessage = vulnerabilities.map(cve => {
      let hoverLine = `* [${cve.cveId}](${cve.link}) - **${cve.severity}** - ${cve.description}`;
      if (cve.patchedVersions.length > 0 && cve.patchedVersions[0] !== 'None') {
        hoverLine += ` - **Fixed in ${cve.patchedVersions.join(', ')}**`;
      }
      return hoverLine;
    }).join('\n');

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
      hoverMessage,
    };
  } catch (error) {
    if (error.response && error.response.status === 429 && retries > 0) {
      // If we receive a 429 error, we delay and retry
      const retryAfter = error.response.headers['retry-after']
        ? parseInt(error.response.headers['retry-after'], 10) * 1000
        : 5000; // Default to 5 seconds if retry-after header is not present
      console.log(`Received 429, retrying after ${retryAfter / 1000} seconds...`);
      await delay(retryAfter);
      return fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries - 1);
    } else {
      console.error(`Error fetching vulnerabilities for ${name}:`, error);
      return { total: 0, highestSeverity: "none" };
    }
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchVulnerabilities(name, version, ecosystem) {
  const response = await axios.get(
    `https://github.com/advisories?query=affects:${name}+ecosystem:${ecosystem}`
  );
  const $ = cheerio.load(response.data);

  const domVulnerabilities = $(".Box-row");
  const vulnerabilities = [];

  const detailPromises = [];

  for (const domVuln of domVulnerabilities) {
    const description = $(domVuln).find("a.Link--primary").text().trim();
    let severity = $(domVuln).find("span.Label").first().text().trim();
    severity = severity === "Moderate" ? "Medium" : severity;
    const cveId = $(domVuln).find("span.text-bold").text().trim();
    const link = $(domVuln).find("a.Link--primary").attr("href").trim();
    const fullLink = `https://github.com${link}`;

    detailPromises.push(
      axios.get(fullLink).then((detailResponse) => {
        const $detailPage = cheerio.load(detailResponse.data);

        $detailPage(".Box-body .Bow-row").each((_, element) => {
          const titleText = $(element).find(".f4.text-bold").text().trim();
          if (titleText.toLowerCase() !== name.toLowerCase()) return; // Continue only if the current block is related to the specified library

          const affectedVersions = $(element).find(".py-2.pr-2:contains('Affected versions') div.f4")
            .map((_, el) => $(el).text().trim())
            .get();
    
          const patchedVersions = $(element).find(".py-2:contains('Patched versions') div.f4")
            .map((_, el) => $(el).text().trim())
            .get();

          // Compare the affected versions with the provided version
          if (isVersionAffected(version, affectedVersions, patchedVersions)) {
            vulnerabilities.push({
              description,
              severity,
              cveId,
              link: fullLink,
              affectedVersions,
              patchedVersions,
            });
          }
        });
      })
    );
  }

  await Promise.all(detailPromises);
  return vulnerabilities;
}

function isVersionAffected(version, affectedVersions, patchedVersions) {
  const normalizeVersion = (ver) =>
    ver
      .replace(/^[^0-9]+/, "")
      .split(".")
      .map(Number);

  const versionNumber = version && typeof version === 'string'
    ? normalizeVersion(version)
    : [Infinity, Infinity, Infinity];

  const isInRange = (range, versionNumber) => {
    return range.split(",").every((bound) => {
      const match = bound.trim().match(/(>=|<=|>|<|~|\^)?\s*([\d.]+)/);
      if (!match) return false;

      const operator = match[1] || "===";
      const boundVersion = normalizeVersion(match[2]);

      switch (operator) {
        case ">=":
          return compareVersions(versionNumber, boundVersion) >= 0;
        case "<=":
          return compareVersions(versionNumber, boundVersion) <= 0;
        case ">":
          return compareVersions(versionNumber, boundVersion) > 0;
        case "<":
          return compareVersions(versionNumber, boundVersion) < 0;
        case "~":
        case "^":
          return (
            compareVersions(versionNumber, boundVersion) >= 0 &&
            compareVersions(
              versionNumber,
              bumpVersion(boundVersion, operator)
            ) < 0
          );
        case "===":
          return compareVersions(versionNumber, boundVersion) === 0;
        default:
          return false;
      }
    });
  };

  const isPatched = patchedVersions.some(
    (patchedVersion) =>
      compareVersions(versionNumber, normalizeVersion(patchedVersion)) === 0
  );

  const isAffected = affectedVersions.some((affectedRange) =>
    isInRange(affectedRange, versionNumber)
  );

  return isAffected && !isPatched;
}

function compareVersions(versionA, versionB) {
  for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
    const a = versionA[i] || 0;
    const b = versionB[i] || 0;
    if (a > b) return 1;
    if (a < b) return -1;
  }
  return 0;
}

function bumpVersion(version, operator) {
  if (operator === "^") {
    if (version[0] > 0) {
      return [version[0] + 1, 0, 0];
    }
    return [0, version[1] + 1, 0];
  }
  if (operator === "~") {
    return [version[0], version[1] + 1, 0];
  }
  return version;
}

function getHighestSeverity(vulnerabilities, counts) {
  let highestSeverity = "none";
  vulnerabilities.forEach((vuln) => {
    switch (vuln.severity.toLowerCase()) {
      case "low":
        counts.low++;
        if (highestSeverity === "low") highestSeverity = "low";
        break;
      case "medium":
        counts.medium++;
        if (["low", "none"].includes(highestSeverity))
          highestSeverity = "medium";
        break;
      case "high":
        counts.high++;
        if (["low", "medium", "none"].includes(highestSeverity))
          highestSeverity = "high";
        break;
      case "critical":
        counts.critical++;
        highestSeverity = "critical";
        break;
    }
  });
  return highestSeverity;
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0)
    parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0)
    parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0)
    parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(", ");
}

function getColorForSeverity(severity) {
  switch (severity) {
    case "low":
      return "yellow";
    case "medium":
      return "orange";
    case "high":
      return "red";
    case "critical":
      return "red";
    default:
      return "green";
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
