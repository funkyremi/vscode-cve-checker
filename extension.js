const path = require("path");
const vscode = require("vscode");
const cheerio = require("cheerio");
const axios = require("axios");

const debouceDelay = 3000;
const pipDependencyFiles = ["requirements.txt", "requirements-dev.txt"];

const decorationType = vscode.window.createTextEditorDecorationType({});

// Home made Debounce
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

function activate() {
  if (vscode.window.activeTextEditor) {
    const { document } = vscode.window.activeTextEditor;
    if (document) {
      if (pipDependencyFiles.includes(path.basename(document.fileName))) {
        const editor = vscode.window.activeTextEditor;
        editor.setDecorations(decorationType, []);
        decoratePythonLibs(document);
      }
    }
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      debounce(decoratePythonLibs(document), debouceDelay);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (
      editor &&
      editor.pipDependencyFiles.includes(
        path.basename(editor.document.fileName)
      )
    ) {
      editor.setDecorations(decorationType, []);
      debounce(decoratePythonLibs(editor.document), debouceDelay);
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    if (pipDependencyFiles.includes(path.basename(document.fileName))) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      debounce(decoratePythonLibs(document), debouceDelay);
    }
  });
}

async function decoratePythonLibs(document) {
  const ecosystem = 'pip';
  const editor = vscode.window.activeTextEditor;
  if (editor && editor.document === document) {
    const lines = document.getText().split("\n");

    const vulnerabilities = await Promise.all(
      lines.map((line) => fetchVulnerabilitySeverityCounts(line.trim(), ecosystem))
    );

    const decorations = vulnerabilities
      .map((vulnDetails, index) => {
        if (vulnDetails.total > 0) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          return {
            range,
            renderOptions: {
              after: {
                contentText: ` ${formatVulnerabilityText(vulnDetails)} `,
                color: getColorForSeverity(vulnDetails.highestSeverity),
                fontWeight: "bold",
              },
            },
          };
        }
        return null;
      })
      .filter((decoration) => decoration !== null);
    editor.setDecorations(decorationType, decorations);
  }
}

function formatLib(libraryString) {
  const [name, version] = libraryString.split("==");
  return {
    name,
    version,
  };
}

async function fetchVulnerabilitySeverityCounts(libraryName, ecosystem) {
  if (!libraryName) return { total: 0, highestSeverity: "none" };

  try {
    const { name, version } = formatLib(libraryName);
    const vulnerabilities = await fetchVulnerabilities(name, version, ecosystem);

    const counts = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };
    let highestSeverity = getHighestSeverity(vulnerabilities, counts);

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
    };
  } catch (error) {
    console.error(`Error fetching vulnerabilities for ${libraryName}:`, error);
    return { total: 0, highestSeverity: "none" };
  }
}

async function fetchVulnerabilities(name, version, ecosystem) {
  // Fetch vulnerabilities related to the library and ecosystem
  const response = await axios.get(
    `https://github.com/advisories?query=affects:${name}+ecosystem:${ecosystem}`
  );
  const $ = cheerio.load(response.data);

  const domVulnerabilities = $(".Box-row");
  const vulnerabilities = [];

  // Collect all promises to fetch detailed vulnerability information
  const detailPromises = [];

  for (let i = 0; i < domVulnerabilities.length; i++) {
    const element = domVulnerabilities[i];
    const description = $(element).find("a.Link--primary").text().trim();
    const severity = $(element).find("span.Label").first().text().trim();
    const cveId = $(element).find("span.text-bold").text().trim();
    const link = $(element).find('a.Link--primary').attr('href').trim();
    const fullLink = `https://github.com${link}`;

    // Add a promise to fetch detailed vulnerability information
    detailPromises.push(
      axios.get(fullLink).then((detailResponse) => {
        const $detailPage = cheerio.load(detailResponse.data);

        const affectedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Affected versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        const patchedVersions = $detailPage(".Box-body h2")
          .filter((_, el) => $(el).text().trim() === "Patched versions")
          .nextAll("div")
          .map((_, el) => $(el).text().trim())
          .get();

        // Compare the affected versions with the provided version
        if (isVersionAffected(version, affectedVersions, patchedVersions)) {
          vulnerabilities.push({
            description,
            severity,
            cveId,
            link: fullLink,
          });
        }
      })
    );
  }

  // Wait for all detail fetches to complete
  await Promise.all(detailPromises);

  return vulnerabilities;
}

function isVersionAffected(version, affectedVersions, patchedVersions) {
  const versionNumber = version.split('.').map(Number);

  const isInRange = (range, versionNumber) => {
    return range.split(',').every(bound => {
      const match = bound.trim().match(/(>=|<=|>|<)?\s*([\d.]+)/);
      if (!match) return false;

      const operator = match[1] || '===';
      const boundVersion = match[2].split('.').map(Number);

      switch (operator) {
        case '>=':
          return compareVersions(versionNumber, boundVersion) >= 0;
        case '<=':
          return compareVersions(versionNumber, boundVersion) <= 0;
        case '>':
          return compareVersions(versionNumber, boundVersion) > 0;
        case '<':
          return compareVersions(versionNumber, boundVersion) < 0;
        case '===':
          return compareVersions(versionNumber, boundVersion) === 0;
        default:
          return false;
      }
    });
  };

  const isPatched = patchedVersions.some(patchedVersion =>
    compareVersions(version.split('.').map(Number), patchedVersion.split('.').map(Number)) === 0
  );

  const isAffected = affectedVersions.some(affectedRange =>
    isInRange(affectedRange, versionNumber)
  );

  return isAffected && !isPatched;
}

function compareVersions(versionA, versionB) {
  for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
    const a = versionA[i] || 0;
    const b = versionB[i] || 0;
    if (a > b) return 1;
    if (a < b) return -1;
  }
  return 0;
}

function getHighestSeverity(vulnerabilities, counts) {
  let highestSeverity = "low";
  vulnerabilities.forEach((vuln) => {
    switch (vuln.severity.toLowerCase()) {
      case "low":
        counts.low++;
        if (highestSeverity === "low") highestSeverity = "low";
        break;
      case "moderate":
        counts.medium++;
        if (["low", "none"].includes(highestSeverity))
          highestSeverity = "medium";
        break;
      case "high":
        counts.high++;
        if (["low", "medium", "none"].includes(highestSeverity))
          highestSeverity = "high";
        break;
      case "critical":
        counts.critical++;
        highestSeverity = "critical";
        break;
    }
  });
  return highestSeverity;
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0)
    parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0)
    parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0)
    parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(", ");
}

function getColorForSeverity(severity) {
  switch (severity) {
    case "low":
      return "#FFCA3A"; // Yellow
    case "medium":
      return "#FD8824"; // Orange
    case "high":
      return "#D31212"; // Red
    case "critical":
      return "#D31212"; // Red
    default:
      return "#000000"; // Black
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
