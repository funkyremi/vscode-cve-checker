const path = require("path");
const vscode = require("vscode");
const cheerio = require("cheerio");
const axios = require("axios");

const pipRegex = /(.+)?requirements(.+)?.txt$/i;
const npmRegex = /^package\.json$/i;
const goRegex = /^go\.mod$/i;
const nugetRegex = /\.csproj$/i;
const composerRegex = /^composer\.json$/i;
const mavenRegex = /^pom\.xml$/i;
const rustRegex = /^Cargo\.toml$/i;

const decorationType = vscode.window.createTextEditorDecorationType({});
const storedDecorations = {};

function debounce(func, wait=3000) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

function activate() {
  if (vscode.window.activeTextEditor) {
    const { document } = vscode.window.activeTextEditor;
    if (document) {
      const editor = vscode.window.activeTextEditor;
      editor.setDecorations(decorationType, []);
      fileName = path.basename(document.fileName)
      if (pipRegex.test(fileName)) {
        decoratePythonLibs(document);
      } else if (npmRegex.test(fileName)) {
        decorateNpmLibs(document);
      } else if (goRegex.test(fileName)) {
        decorateGoLibs(document);
      } else if (nugetRegex.test(fileName)) {
        decorateNugetLibs(document);
      } else if (composerRegex.test(fileName)) {
        decorateComposerLibs(document);
      } else if (mavenRegex.test(fileName)) {
        decorateMavenLibs(document);
      } else if (rustRegex.test(fileName)) {
        decorateRustLibs(document);
      }
    }
  }

  vscode.workspace.onDidOpenTextDocument((document) => {
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    fileName = path.basename(document.fileName)
    if (pipRegex.test(fileName)) {
      decoratePythonLibs(document);
    } else if (npmRegex.test(fileName)) {
      decorateNpmLibs(document);
    } else if (goRegex.test(fileName)) {
      decorateGoLibs(document);
    } else if (nugetRegex.test(fileName)) {
      decorateNugetLibs(document);
    } else if (composerRegex.test(fileName)) {
      decorateComposerLibs(document);
    } else if (mavenRegex.test(fileName)) {
      decorateMavenLibs(document);
    } else if (rustRegex.test(fileName)) {
      decorateRustLibs(document);
    }
  });

  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor?.document) {
      document = editor.document
      if (storedDecorations[document.fileName]) {
        editor.setDecorations(decorationType, storedDecorations[document.fileName]);
      } else {
        fileName = path.basename(document.fileName)
        editor.setDecorations(decorationType, []);
        if (pipRegex.test(fileName)) {
          decoratePythonLibs(document);
        } else if (npmRegex.test(fileName)) {
          decorateNpmLibs(document);
        } else if (goRegex.test(fileName)) {
          decorateGoLibs(document);
        } else if (nugetRegex.test(fileName)) {
          decorateNugetLibs(document);
        } else if (composerRegex.test(fileName)) {
          decorateComposerLibs(document);
        } else if (mavenRegex.test(fileName)) {
          decorateMavenLibs(document);
        } else if (rustRegex.test(fileName)) {
          decorateRustLibs(document);
        }
      }
    }
  });

  vscode.workspace.onDidChangeTextDocument((event) => {
    const { document } = event;
    const editor = vscode.window.activeTextEditor;
    editor.setDecorations(decorationType, []);
    fileName = path.basename(document.fileName)
    if (pipRegex.test(fileName)) {
      debounce(() => decoratePythonLibs(document))();
    } else if (npmRegex.test(fileName)) {
      debounce(() => decorateNpmLibs(document))();
    } else if (goRegex.test(fileName)) {
      debounce(() => decorateGoLibs(document))();
    } else if (nugetRegex.test(fileName)) {
      debounce(() => decorateNugetLibs(document))();
    } else if (composerRegex.test(fileName)) {
      debounce(() => decorateComposerLibs(document))();
    } else if (mavenRegex.test(fileName)) {
      debounce(() => decorateMavenLibs(document))();
    } else if (rustRegex.test(fileName)) {
      debounce(() => decorateRustLibs(document))();
    }
  });
}

function formatPythonLib(libraryString) {
  const [dep, version] = libraryString.split("==");
  return {
    dep,
    version,
  };
}

async function decoratePythonLibs(document) {
  const ecosystem = "pip";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const lines = document.getText().split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();
      if (line && line !== "" && !line.startsWith("#")) {
        const { dep, version } = formatPythonLib(line);

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

        const position = new vscode.Position(index, lines[index].length);
        const range = new vscode.Range(position, position);

        const decoration = {
          range,
          renderOptions: {
            after: {
              contentText: vulnDetails.total > 0
                ? ` ${formatVulnerabilityText(vulnDetails)} `
                : " No CVE found",
              color: getColorForSeverity(vulnDetails?.highestSeverity),
              fontWeight: "bold",
            },
          },
          hoverMessage: vulnDetails.total > 0
            ? new vscode.MarkdownString(vulnDetails.hoverMessage)
            : null,
        };

        decorations.push(decoration);

        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateNpmLibs(document) {
  const ecosystem = "npm";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    let json;
    try {
      json = JSON.parse(text);
    } catch(e) {
      console.error('JSON file not valid', e);
    }

    const dependencies = {
      ...json.dependencies,
      ...json.devDependencies,
    };

    const lines = text.split("\n");

    let decorations = [];

    for (const dep of Object.keys(dependencies)) {
      const version = dependencies[dep];

      const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

      const lineIndex = lines.findIndex((line) =>
        line.includes(`"${dep}":`)
      );

      if (lineIndex !== -1) {
        const position = new vscode.Position(
          lineIndex,
          lines[lineIndex].length
        );
        const range = new vscode.Range(position, position);

        const decoration = {
          range,
          renderOptions: {
            after: {
              contentText: vulnDetails.total > 0
                ? ` ${formatVulnerabilityText(vulnDetails)} `
                : " No CVE found",
              color: getColorForSeverity(vulnDetails?.highestSeverity),
              fontWeight: "bold",
            },
          },
          hoverMessage: vulnDetails.total > 0
            ? new vscode.MarkdownString(vulnDetails.hoverMessage)
            : null,
        };

        decorations.push(decoration);

        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateGoLibs(document) {
  const ecosystem = "go";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Match dependencies in go.mod file
      const match = line.match(/^(\S+)\s+v([\d.]+[-\w]*).*$/);
      if (match) {
        const dep = match[1]; // Dependency name
        const version = match[2]; // Dependency version

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateNugetLibs(document) {
  const ecosystem = "nuget";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Match dependencies in .csproj file
      const match = line.match(/<PackageReference Include="([^"]+)" Version="([^"]+)"\s*\/>/);
      if (match) {
        const dep = match[1]; // Dependency name
        const version = match[2]; // Dependency version

        const vulnDetails = await fetchVulnerabilitySeverityCounts(dep.toLowerCase(), version, ecosystem);

        if (line.includes(dep)) {
          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateComposerLibs(document) {
  const ecosystem = "composer";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    let json;
    try {
      json = JSON.parse(text);
    } catch(e) {
      console.error('JSON file not valid', e);
    }

    const dependencies = {
      ...json.require,
      ...json['require-dev'],
    };

    const lines = text.split("\n");

    let decorations = [];

    for (const dep of Object.keys(dependencies)) {
      const version = dependencies[dep];

      const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

      const lineIndex = lines.findIndex((line) =>
        line.includes(`"${dep}":`)
      );

      if (lineIndex !== -1) {
        const position = new vscode.Position(
          lineIndex,
          lines[lineIndex].length
        );
        const range = new vscode.Range(position, position);

        const decoration = {
          range,
          renderOptions: {
            after: {
              contentText: vulnDetails.total > 0
                ? ` ${formatVulnerabilityText(vulnDetails)} `
                : " No CVE found",
              color: getColorForSeverity(vulnDetails?.highestSeverity),
              fontWeight: "bold",
            },
          },
          hoverMessage: vulnDetails.total > 0
            ? new vscode.MarkdownString(vulnDetails.hoverMessage)
            : null,
        };

        decorations.push(decoration);

        editor.setDecorations(decorationType, decorations);
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateMavenLibs(document) {
  const ecosystem = "maven";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const text = document.getText();
    const lines = text.split("\n");

    let decorations = [];

    // Regex to match Maven dependency blocks
    const dependencyRegex = /<dependency>\s*<groupId>([^<]+)<\/groupId>\s*<artifactId>([^<]+)<\/artifactId>\s*<version>([^<]+)<\/version>/;

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Check if the line contains the <dependency> tag
      if (line.includes('<dependency>')) {
        // Accumulate lines to form the complete dependency block
        let depBlock = line;
        let depStartIndex = index; // Store the start index of the dependency block
        while (!depBlock.includes('</dependency>') && index < lines.length) {
          index++;
          depBlock += lines[index].trim();
        }

        // Match the complete dependency block against the regex
        const match = depBlock.match(dependencyRegex);
        if (match) {
          const groupId = match[1];  // Group ID
          const artifactId = match[2];  // Artifact ID
          const version = match[3];  // Version

          const vulnDetails = await fetchVulnerabilitySeverityCounts(`${groupId}:${artifactId}`, version, ecosystem);

          // Set the position to the line containing the <dependency> start tag
          const position = new vscode.Position(depStartIndex, lines[depStartIndex].indexOf('<dependency>') + '<dependency>'.length); // Position after the <dependency> tag
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }
    storedDecorations[document.fileName] = decorations;
  }
}

async function decorateRustLibs(document) {
  const ecosystem = "rust";
  const editor = vscode.window.activeTextEditor;

  if (editor && editor.document === document) {
    const lines = document.getText().split("\n");

    let decorations = [];
    let isInDependenciesSection = false;

    // Regex to match Rust dependencies in Cargo.toml (e.g., serde = "1.0.80")
    const dependencyRegex = /^([\w\-_]+)\s*=\s*"([\d\.\*]+)"/;

    for (let index = 0; index < lines.length; index++) {
      const line = lines[index].trim();

      // Track if we are in the [dependencies] or [dev-dependencies] section
      if (line.startsWith("[dependencies]") || line.startsWith("[dev-dependencies]")) {
        isInDependenciesSection = true;
      } else if (line.startsWith("[") && isInDependenciesSection) {
        // Exit dependencies section if another section starts
        isInDependenciesSection = false;
      }

      // Only process lines inside the dependencies section
      if (isInDependenciesSection) {
        const match = line.match(dependencyRegex);
        if (match) {
          const dep = match[1]; // Dependency name
          const version = match[2]; // Dependency version

          // Fetch vulnerability details for the specific dependency and version
          const vulnDetails = await fetchVulnerabilitySeverityCounts(dep, version, ecosystem);

          const position = new vscode.Position(index, lines[index].length);
          const range = new vscode.Range(position, position);

          const decoration = {
            range,
            renderOptions: {
              after: {
                contentText: vulnDetails.total > 0
                  ? ` ${formatVulnerabilityText(vulnDetails)} `
                  : " No CVE found",
                color: getColorForSeverity(vulnDetails?.highestSeverity),
                fontWeight: "bold",
              },
            },
            hoverMessage: vulnDetails.total > 0
              ? new vscode.MarkdownString(vulnDetails.hoverMessage)
              : null,
          };

          decorations.push(decoration);

          editor.setDecorations(decorationType, decorations);
        }
      }
    }

    storedDecorations[document.fileName] = decorations;
  }
}

async function fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries = 3) {
  if (!name) return { total: 0, highestSeverity: "none" };

  try {
    const vulnerabilities = await fetchVulnerabilities(name, version, ecosystem);

    const counts = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };
    let highestSeverity = getHighestSeverity(vulnerabilities, counts);

    const hoverMessage = vulnerabilities.map(cve => {
      let hoverLine = `* [${cve.cveId}](${cve.link}) - **${cve.severity}** - ${cve.description}`;
      if (cve.patchedVersions.length > 0 && cve.patchedVersions[0] !== 'None') {
        hoverLine += ` - **Fixed in ${cve.patchedVersions.join(', ')}**`;
      }
      return hoverLine;
    }).join('\n');

    return {
      total: counts.low + counts.medium + counts.high + counts.critical,
      counts,
      highestSeverity,
      hoverMessage,
    };
  } catch (error) {
    if (error.response && error.response.status === 429 && retries > 0) {
      // If we receive a 429 error, we delay and retry
      const retryAfter = error.response.headers['retry-after']
        ? parseInt(error.response.headers['retry-after'], 10) * 1000
        : 5000; // Default to 5 seconds if retry-after header is not present
      console.log(`Received 429, retrying after ${retryAfter / 1000} seconds...`);
      await delay(retryAfter);
      return fetchVulnerabilitySeverityCounts(name, version, ecosystem, retries - 1);
    } else {
      console.error(`Error fetching vulnerabilities for ${name}:`, error);
      return { total: 0, highestSeverity: "none" };
    }
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchVulnerabilities(name, version, ecosystem) {
  // Fetch vulnerabilities related to the library and ecosystem
  const response = await axios.get(
    `https://github.com/advisories?query=affects:${name}+ecosystem:${ecosystem}`
  );
  const $ = cheerio.load(response.data);

  const domVulnerabilities = $(".Box-row");
  const vulnerabilities = [];

  const detailPromises = [];

  for (const domVuln of domVulnerabilities) {
    const description = $(domVuln).find("a.Link--primary").text().trim();
    let severity = $(domVuln).find("span.Label").first().text().trim();
    severity = severity === "Moderate" ? "Medium" : severity;
    const cveId = $(domVuln).find("span.text-bold").text().trim();
    const link = $(domVuln).find("a.Link--primary").attr("href").trim();
    const fullLink = `https://github.com${link}`;

    // Add a promise to fetch detailed vulnerability information
    detailPromises.push(
      axios.get(fullLink).then((detailResponse) => {
        const $detailPage = cheerio.load(detailResponse.data);

        $detailPage(".Box-body .Bow-row").each((_, element) => {
          const titleText = $(element).find(".f4.text-bold").text().trim();
          if (titleText.toLowerCase() !== name.toLowerCase()) return; // Continue only if the current block is related to the specified library

          const affectedVersions = $(element).find(".py-2.pr-2:contains('Affected versions') div.f4")
            .map((_, el) => $(el).text().trim())
            .get();
    
          const patchedVersions = $(element).find(".py-2:contains('Patched versions') div.f4")
            .map((_, el) => $(el).text().trim())
            .get();

          // Compare the affected versions with the provided version
          if (isVersionAffected(version, affectedVersions, patchedVersions)) {
            vulnerabilities.push({
              description,
              severity,
              cveId,
              link: fullLink,
              affectedVersions,
              patchedVersions,
            });
          }
        });
      })
    );
  }

  await Promise.all(detailPromises);
  return vulnerabilities;
}

function isVersionAffected(version, affectedVersions, patchedVersions) {
  const normalizeVersion = (ver) =>
    ver
      .replace(/^[^0-9]+/, "")
      .split(".")
      .map(Number);

  const versionNumber = version && typeof version === 'string'
    ? normalizeVersion(version)
    : [Infinity, Infinity, Infinity];

  const isInRange = (range, versionNumber) => {
    return range.split(",").every((bound) => {
      const match = bound.trim().match(/(>=|<=|>|<|~|\^)?\s*([\d.]+)/);
      if (!match) return false;

      const operator = match[1] || "===";
      const boundVersion = normalizeVersion(match[2]);

      switch (operator) {
        case ">=":
          return compareVersions(versionNumber, boundVersion) >= 0;
        case "<=":
          return compareVersions(versionNumber, boundVersion) <= 0;
        case ">":
          return compareVersions(versionNumber, boundVersion) > 0;
        case "<":
          return compareVersions(versionNumber, boundVersion) < 0;
        case "~":
        case "^":
          return (
            compareVersions(versionNumber, boundVersion) >= 0 &&
            compareVersions(
              versionNumber,
              bumpVersion(boundVersion, operator)
            ) < 0
          );
        case "===":
          return compareVersions(versionNumber, boundVersion) === 0;
        default:
          return false;
      }
    });
  };

  const isPatched = patchedVersions.some(
    (patchedVersion) =>
      compareVersions(versionNumber, normalizeVersion(patchedVersion)) === 0
  );

  const isAffected = affectedVersions.some((affectedRange) =>
    isInRange(affectedRange, versionNumber)
  );

  return isAffected && !isPatched;
}

function compareVersions(versionA, versionB) {
  for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
    const a = versionA[i] || 0;
    const b = versionB[i] || 0;
    if (a > b) return 1;
    if (a < b) return -1;
  }
  return 0;
}

function bumpVersion(version, operator) {
  if (operator === "^") {
    if (version[0] > 0) {
      return [version[0] + 1, 0, 0];
    }
    return [0, version[1] + 1, 0];
  }
  if (operator === "~") {
    return [version[0], version[1] + 1, 0];
  }
  return version;
}

function getHighestSeverity(vulnerabilities, counts) {
  let highestSeverity = "none";
  vulnerabilities.forEach((vuln) => {
    switch (vuln.severity.toLowerCase()) {
      case "low":
        counts.low++;
        if (highestSeverity === "low") highestSeverity = "low";
        break;
      case "medium":
        counts.medium++;
        if (["low", "none"].includes(highestSeverity))
          highestSeverity = "medium";
        break;
      case "high":
        counts.high++;
        if (["low", "medium", "none"].includes(highestSeverity))
          highestSeverity = "high";
        break;
      case "critical":
        counts.critical++;
        highestSeverity = "critical";
        break;
    }
  });
  return highestSeverity;
}

function formatVulnerabilityText(vulnDetails) {
  const parts = [];
  if (vulnDetails.counts.low > 0) parts.push(`Low: ${vulnDetails.counts.low}`);
  if (vulnDetails.counts.medium > 0)
    parts.push(`Medium: ${vulnDetails.counts.medium}`);
  if (vulnDetails.counts.high > 0)
    parts.push(`High: ${vulnDetails.counts.high}`);
  if (vulnDetails.counts.critical > 0)
    parts.push(`Critical: ${vulnDetails.counts.critical}`);
  return parts.join(", ");
}

function getColorForSeverity(severity) {
  switch (severity) {
    case "low":
      return "yellow";
    case "medium":
      return "orange";
    case "high":
      return "red";
    case "critical":
      return "red";
    default:
      return "green";
  }
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
